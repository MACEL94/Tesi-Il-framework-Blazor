\chapter{Modelli e Funzionamento}\label{cap:modefunz}
\section{Blazor Server}\label{sez:bserver}
Il primo dei modelli ufficialmente rilasciati e per il quale si pu\'o ricevere supporto in produzione da settembre 2019\cite{blazorServerRelease}, \'e proprio questo.

Un'applicazione Blazor Server ospita i componenti Blazor lato Server e gestisce le interazioni dell'utente con la UI attraverso una connessione in tempo reale sfruttando SignalR, come visibile nella figura 2.1.

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.6]{figure/blazor-server.png}}
	\caption{Blazor Server}
	\label{fig:BlazorServer}
\end{figure}

Ci\'o significa che quando un utente scatena un evento, questo viene inviato attraverso la real time connection al server, dove il rispettivo componente di competenza gestisce l'evento.
Quando l'evento \'e stato gestito, blazor compara l'output appena generato con quello precedente all'evento, e manda quindi le sole differenze al browser del client, per poi applicarle al DOM.\cite{blazorModelsScenarios}

Blazor Server perci\'o necessita di una connessione stabile e a bassa latenza per funzionare al meglio, e gli scenari offline non sono supportati.
Ci\'o significa anche che la posizione del server sul quale \'e ospitata l'applicazione non pu\'o essere troppo distante dal client che si sta connettendo per garantire un funzionamento senza lag.

\'E particolarmente indicato quando si vuole delegare il costo computazionale al server e non ai client connessi, dato che ci\'o che il client esegue \'e il solo codice statico e le differenze di volta in volta inviate ma calcolate lato server.
Ci\'o rende molto veloce ed efficiente il download e l'avvio dell'applicazione lato client, il che lo rende il modello perfetto per funzionare su apparecchi a basso costo.

\subsection{BlazorPong }\label{sez:bpong}
Un'esempio di applicazione scritta con questo modello, \'e BlazorPong, da me implementata e la cui demo \'e disponibile sul relativo repository in GitHub\cite{blazorPong}.

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.3]{figure/BlazorPong.PNG}}
	\caption{BlazorPong}
	\label{fig:BlazorPong}
\end{figure}

Visibile nella figura  questa applicazione permette a due giocatori che si collegano al sito contemporaneamente di giocare, e ai successivi utenti che si collegano di visionare la partita in corso come spettatori in tempo reale.
In questa applicazione ho scelto di utilizzare il modello server side per vari motivi:
\begin{enumerate}
	\item Il service worker che si occupa di aggiornare la posizione della pallina su tutti i client connessi, deve essere eseguito in un unico thread utilizzato per tutti i client connessi al server, ad ognuno dei quali invece devono arrivare gli aggiornamenti.
	\item Il calcolo delle differenze da applicare a ciascun DOM di ciascun utente connesso, per quanto avvenga continuamente(60fps circa), conviene avvenga direttamente lato server poich\'e l'applicazione \'e molto semplice e infatti anche un host di livello gratuito come quello che ho utilizzato riesce a far giocare senza problemi due persone con diversi spettatori(i test che ho fatto sono tutti dall'europa, poich\'e il server utilizzato si trova in Francia).
	\item Essendo la gestione degli eventi server side, il gioco pu\'o essere visualizzato in modalit\'a spettatore senza problemi anche su cellulari non molto performanti.
	
\end{enumerate}

Il funzionamento \'e piuttosto semplice: una volta che l'applicazione \'e stata avviata e che ciascun player si \'e connesso al sito ed ha cliccato play, quindi quando entrambi gli utenti sono pronti a giocare, inizia la partita.
Lato server viene gestito lo spostamento costante della pallina ed eventuali collisioni con muri verticali, orizzontali o con il blocco di uno dei player.
Rispettivamente gli eventi gestiti direttamente dal background worker sono quindi:
\begin{enumerate}
	\item Punto per il player dal lato opposto in cui avviene la collisione con un muro verticale;
	\item Inversione della velocit\'a di spostamento della pallina sull'asse y a seguito di una collisione con un muro orizzontale;
	\item Inversione della velocit\'a di spostamento della pallina sugli assi x ed y a seguito di una collisione con uno dei player;
	\item Invio di messaggio di fine partita contenente il player vincitore a tutti gli utenti connessi quando un utente arriva a 3 punti o uno dei due player si disconnette.
\end{enumerate}

Ci\'o che invece avviene grazie all'utente, \'e lo spostamento del proprio player attraverso l'evento di drag del proprio blocco.
Ad ogni evento scatenato dall'utente, la connessione SignalR invia l'evento al server, che lo processa e restituisce a tutti gli utenti connessi(compreso quello che ha scatenato l'evento) la differenza di CSS necessaria a far combaciare la nuova posizione reale del blocco del player che si \'e mosso, con l'immagine visualizzata.

\pagebreak

\section{Blazor WebAssembly}\label{sez:bwa}
Blazor WebAssembly \'e un modello attualmente in preview, che verr\'a ufficialmente rilasciato nella prima parte del 2020.

In questo modello il codice della SPA viene eseguito completamente lato client come solitamente avviene quando si utilizza un framework moderno per UI basato su JS, come i gi\'a citati Angular,React,Vue.

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.6]{figure/blazor-WebAssembly.png}}
	\caption{Blazor WebAssembly}
	\label{fig:BlazorWebAssembly}
\end{figure}

Vengono quindi scaricati dal client l'applicazione Blazor, le sue dipendenze, ed il runtime del .NET scelto come target per l'applicazione.
L'applicazione viene quindi eseguita direttamente nel thread della User Interface del Browser utilizzato, come visibile nella figura 2.2.

L'ambito di esecuzione \'e la stessa sandbox di qualsiasi altra applicazione scritta con javascript, ossia il browser che si sta utilizzando.
Ci\'o \'e importante perch\'e implica(ed \'e cos\'i) che una web app scritta utilizzando Blazor non pu\'o fare niente di pi\'u o di meno di una web app standard.
Ogni update alla UI e la relativa gestione, avvengono utilizzando lo stesso processo nel browser.
Per questo modello, blazor.WebAssembly.js \'e il nome dello script Javascript che si occupa di scaricare il .NET runtime, l'applicazione e le dipendenze, come anche dell'inizializzazione dell'applicazione.

\subsection{WebAssembly}\label{sez:webAssembly}
In particolare il nome Blazor WebAssembly \'e stato scelto perch\'e utilizzlato client il codice viene eseguito grazie al file mono.wasm, ossia la compilazione del Runtime del framework Mono in WebAssembly, e Mono \'e una delle implementazioni esistenti del framework di base .NET Standard.
Il WebAssembly, che \'e un open standard che definisce un formato portatile di codice binario per programmi eseguibili e il rispettivo linguaggio assembly, come anche delle interfacce per facilitare le interazioni del codice con il proprio host.
\'E anche detto il byte code del web, dato che dal 2017 i browser pi\'u diffusi al mondo si sono impegnati per svilupparlo ed adottarlo.\cite{webAssemblySupport}

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.7]{figure/WasmVSJavascript.PNG}}
	\caption{Confronto tra WebAssembly e Javascript}
	\label{fig:WasmVSJavascript}
\end{figure}
Come si pu\'o vedere nella figura 2.3, uno dei motivi per cui WASM \'e pi\'u veloce di Javascript \'e che non deve essere processato e compilato prima di poter essere interpretato, ma solamente scompattato ed eseguito.

La compilazione avviene in modalita AOT(Ahead of Time) e non pi\'u JIT(Just in Time), il che si traduce in un sensibile miglioramenteo delle prestazioni del codice dinamico.
Il C\# quindi non \'e l'unico linguaggio che potr\'a essere utilizzato come partenza per essere compilato in WASM, tuttavia questa tecnologia \'e ci\'o che rende possibile il funzionamento di Blazor.

In questo modello quindi, come visibile dai Chrome Developer Tools, vengono scaricate le DLL dell'applicazione direttamente nel browser dell'utente.

\subsection{Blazor PWA}\label{sez:bpwa}
Lo step successivo per avvicinarsi al client allontanandosi dal modello server \'e poi Blazor PWA.

\'E cos\'i chiamato perch\'e in questo modello Blazor, permette di sviluppare l'interfaccia utente di una Progressive Web App.
Nella figura 2.3 viene riassunto cosa sia una Progressive Web App.

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.5]{figure/ProgressiveWebApp.png}}
	\caption{Progressive Web Apps}
	\label{fig:WhatIsAPWA}
\end{figure}

In particolare queste sono applicazioni web che hanno la capacit\'a di funzionare anche offline, e che spesso possono essere scaricate in modo persistente sulla macchina dell'utente che le esegue.
Offrono chiaramente una maggiore velocit\'a di esecuzione e la possibilit\'a di sfruttare alcune API native.
Ad esempio possono essere utilizzate quando la necessit\'a \'e quella di utilizzare le notifiche push native del SO che sta utilizzando il client(e.g. Windows).

Per realizzarne una in Blazor al momento, bisogna partire dal modello Blazor WebAssembly aggiungendo un manifesto che descriva le capacit\'a dell'applicazione, i permessi richiesti e l'icona da utilizzare una volta installata, oltre chiaramente a dover implementare l'applicazione in modo che possa lavorare anche offline, basandosi su un service worker.\cite{blazorPWA}
\pagebreak

\section{Modelli in roadmap}
\subsection{Blazor Hybrid}\label{sez:bhybrid}
Questo modello di Blazor ed anche il successivo, servono a sviluppare applicazioni native.
Nel modello Hybrid, l'applicazione sviluppata non \'e quindi pi\'u considerabile una web app ma rimane ibrida perch\'e pur essendo un app nativa, utilizza tecnologie web per effettuare il rendering della user interface.

Esempi di Hybrid Apps possono essere applicazioni mobile native, che hanno accesso alle API esposte ad esempio da Android, ma che utilizzano delle WebViews per la gestione dell'interazione dell'utente con la UI.

Un'altro esempio molto interessante sono le applicazioni che sfruttano Electron, che permette di compilare un'applicazione web in un applicazione desktop cross platform.
Infatti utilizzando Electron si pu\'o creare un'applicazione nativa, con l'interfaccia utente scritta utilizzando blazor, facendo in modo che in fase di esecuzione il processo host sia .NET Core(avendo quindi pieno accesso alle capacit\'a native e ad esempio al file system) pur rimanendo cross platform e potendo quindi eseguire su Windows, Linux e Mac.
Di seguito nell'immagine 2.4 si pu\'o vedere una Web Application compilata nativamente con Electron(con target Windows), e quindi eseguita come applicazione desktop:

\begin{figure}[H]
	\centerline{\includegraphics[scale=0.6]{figure/BlazorWeatherElectron.png}}
	\caption{Blazor Hybrid Application}
	\label{fig:BlazorHybridApplication}
\end{figure}

Il codice open source dell'applicazione qui sopra, si trovare al seguente link: https://github.com/danroth27/BlazorWeather/tree/master/BlazorWeather.Electron
\pagebreak



\subsection{Blazor Native}\label{sez:bnative}
Infine esiste il modello Native che \'e possibile grazie al fatto che Blazor \'e stato architettato per poter renderizzare controlli della User Interface che non siano obbligatoriamente strumenti web, e pu\'o quindi integrarsi con controlli nativi.
Il rendering layer \'e infatti intercambiabile, pur essendo quello di default dedicato all'HTML.

Un esempio di applicazione sviluppata utilizzando Blazor per il rendering di controlli nativi nella user interface, si pu\'o vedere durante la presentazione di Steve Sanderson all' evento NDC Oslo di quest'anno, pur non essendo stato ancora rilasciato il codice di un esempio ufficiale.\cite{sandersonNDCBlutter}
In questa applicazione, si \'e scelto di sostituire il default rendering layer per utilizzarne uno custom, utilizzando componenti di Flutter, il toolkit di Google per costruire interfacce utente native CrossPlatform.
Questo modello viene qui citato per completezza, ma al momento non \'e nemmeno presente nella documentazione ufficiale ed \'e solo stato citato da Daniel Roth durante la presentazione dei futuri modelli di Blazor lato client.\cite{blazorNative}

\section{Funzionamento}\label{sez:funzionamento}
Partendo dal codice, come gi\'a anticipato quando si scrive si utilizza un mix di HTML per lo scheletro, CSS per lo stile del documento e C\# preceduto dal relativo carattere di escape(@) per la parte dinamica del codice.
\begin{figure}[H]
	\centerline{\includegraphics[scale=0.7]{figure/RazorFile.png}}
	\caption{File Razor\cite{ryanNowakNDCSydney}}
	\label{fig:razorFile}
\end{figure}
Si pu\'o scrivere utilizzando questa sintassi solamente nei file che hanno estensione ".razor", il cui esempio si pu\'o vedere in figura 2.7.
Quando l'applicazione viene compilata, i file .razor vengono utilizzati come base per generare dei file C\#(.cs) equivalenti al codice che si \'e descritto, e saranno poi questi file ad essere effettivamente utilizzati da Roslyn(che \'e il nome del compilatore open-source del linguaggio C\#) e a finire nella DLL generata come output del progetto.
Un esempio di output di file razor compilato, generato a partire da quello in figura 2.7 \'e visibile in figura 2.8.
\begin{figure}[H]
	\centerline{\includegraphics[scale=0.75]{figure/RazorFileCompiled.PNG}}
	\caption{Output\cite{ryanNowakNDCSydney}}
	\label{fig:compiledRazorFile}
\end{figure}
\pagebreak